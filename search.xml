<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>实现一个简单的Python Web框架</title>
    <url>/2020/03/18/%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84web%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>实现一个简单的Python Web框架</p>
<a id="more"></a>
<p>待完成</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>web</tag>
        <tag>WSGI</tag>
      </tags>
  </entry>
  <entry>
    <title>web简介</title>
    <url>/2020/03/16/web%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>基于爬虫监控系统的一次简单的web内容分享</p>
<a id="more"></a>

<h4 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h4><p>前端与后端之间有两种协作方式，一种是<code>服务器端渲染</code>，一种是<code>前后端分离</code>。</p>
<p>服务器端渲染的方式，是指在服务器端就将网页直接生成，浏览器这里拿到的是一整个网页，CSS和JS的部分是在浏览器端执行的，而Html网页的内容部分，是由服务器端生成的。<br>第二种方式就是前后端分离的方式，是浏览器端先拿到HTML，然后通过调用后端接口获取数据。</p>
<p>所以两种方式的区别关键，就在于是，HTML是在哪儿生成的，浏览器和服务端传递的是什么。<br>在前后端分离的方式，浏览器和服务端传递的是数据，而在服务器端渲染的过程中，传递的是HTML网页。</p>
<p>以上是这两种方式的差别，下面介绍一下这两种方式的优劣。</p>
<p><strong>1 数据量</strong><br>前后端分离中传递数据，所以传输量比较小。<br>服务器端渲染，会传输更大的数据，而且，会有很多内容是重复的。<br><strong>2 体验</strong><br>前后端多了一个渲染数据的过程，服务器端省去了这个过程。这也是一直被提到的首屏渲染的问题。<br><strong>3 解耦</strong><br>前后端分离中，传输的是数据，Model，数据怎么展示，全部交给前端来处理，后端只负责提供数据。<br>服务器端渲染中，传输的是Html，后端传给前端的Model，通常是通过Hidden的Input来处理，或者是直接用模板技术生成.数据和展现并未分离。<br><strong>4 控制</strong><br>网页之间有各种跳转交互，在前后端分离中，跳转的页面控制，全部是由前端来决定。跟后端完全没有关系。<br>在服务器端渲染的方式中，大部分是由后端来决定，少部分是由前端来决定。<br><strong>5 SEO</strong><br>前后端分离的方式，通常的载体是SPA，所以拿到的是没有数据的空壳子，很多搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。<br>而服务器端渲染的方式，因为生成的是网页，所以对SEO支持比较好。</p>
<blockquote>
<p><em>SEO: 搜索引擎优化</em><br><em>SPA: 单页面应用</em></p>
</blockquote>
<h4 id="技术栈介绍"><a href="#技术栈介绍" class="headerlink" title="技术栈介绍"></a>技术栈介绍</h4><p><strong>前端</strong><br><a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">vue</a> + <a href="https://vuex.vuejs.org/zh/guide/" target="_blank" rel="noopener">VueX</a> + <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">Vue Router</a><br>参考了后台前端解决方案<a href="https://panjiachen.github.io/vue-element-admin-site/zh/" target="_blank" rel="noopener">vue-element-admin</a></p>
<p><strong>后端</strong><br><a href="https://www.djangoproject.com/" target="_blank" rel="noopener">django</a> + <a href="https://graphql.cn/" target="_blank" rel="noopener">graphql</a></p>
<p><strong>部署</strong><br>nginx + uwsgi</p>
<h4 id="WSGI协议简介"><a href="#WSGI协议简介" class="headerlink" title="WSGI协议简介"></a>WSGI协议简介</h4><p>Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。该规范的具体描述在<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP3333</a>。</p>
<p>WSGI主要分为两个部分：<br><strong>Server/Gateway:</strong> 即是HTTP Server，负责从客户端接收http请求，对http请求进行解析，然后调用application，给application提供两个参数environ（环境信息）、start_response（一个回调函数，这个回调函数是用来将应用程序设置的http header和status等信息传递给服务器方），并将application返回的response返回给客户端。<br><strong>Application/Framework:</strong> 一个python web应用或web框架，处理请求，生成返回的header、body和status，并将处理结果返回给server。<br><strong>Middleware:</strong>  略过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># wsgiref.simple_server.demo_app</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_app</span><span class="hljs-params">(environ, start_response)</span>:</span><br>    <span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIO<br>    stdout = StringIO()<br>    print(<span class="hljs-string">"Hello world!"</span>, file=stdout)<br>    print(file=stdout)<br>    h = sorted(environ.items())<br>    <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> h:<br>        print(k,<span class="hljs-string">'='</span>,repr(v), file=stdout)<br>    start_response(<span class="hljs-string">"200 OK"</span>, [(<span class="hljs-string">'Content-Type'</span>,<span class="hljs-string">'text/plain; charset=utf-8'</span>)])<br>    <span class="hljs-keyword">return</span> [stdout.getvalue().encode(<span class="hljs-string">"utf-8"</span>)]<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span>:</span><br>    ...<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self, environ, start_response)</span>:</span><br>        body = <span class="hljs-string">b"..."</span><br>        status = <span class="hljs-string">"200 OK"</span><br>        headers = [(<span class="hljs-string">"key"</span>, <span class="hljs-string">"value"</span>), ...]<br>        start_response(status, headers)<br>        <span class="hljs-keyword">return</span> [body]<br></code></pre></td></tr></table></figure>

<p>flask、django、tornado都是wsgi框架，使用框架，我们只需要实现业务逻辑。WSGI把来自socket的数据包解析为http格式，Server会传递environ跟start_response给Application，等到Application返回值之后，再socket send返回客户端。<br>Django开发服务器使用的是python原生的wsgiref工具包。<br>Flask自带了一个基于Werkzeug的调试用服务器。根据Flask的文档，在生产环境不应该使用内建的调试服务器，而应该采取以下方式之一进行部署：</p>
<blockquote>
<p>GUNICORN<br>UWSGI</p>
</blockquote>
<p>WSGI的优点:<br>多样的部署选择和组件之间的高度解耦。<br>由于上面提到的高度解耦特性，理论上，任何一个符合WSGI规范的App都可以部署在任何一个实现了WSGI规范的Server上，这给Python Web应用的部署带来了极大的灵活性。<br>缺点: 未发现</p>
<h4 id="跨域资源共享CORS介绍"><a href="#跨域资源共享CORS介绍" class="headerlink" title="跨域资源共享CORS介绍"></a>跨域资源共享CORS介绍</h4><p>当一个资源从与该资源本身所在的服务器不同的<code>域、协议或端口</code>请求一个资源时，资源会发起一个<code>跨域HTTP请求</code>。<br>出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。例如，XMLHttpRequest和Fetch API遵循同源策略。<br>这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，<code>除非响应报文包含了正确CORS响应头</code>。<br><em>所以跨域限制访问，其实是浏览器的限制。</em><br><em>说明：并不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了（后文有说明）。</em></p>
<p>跨域资源共享（CORS）机制允许Web应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在API容器中（例如XMLHttpRequest或Fetch使用CORS，以降低跨域HTTP请求所带来的风险。</p>
<p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>若请求满足所有下述条件，则该请求可视为“简单请求”：</p>
<ul>
<li>使用下列方法之一：<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
</li>
<li>HTTP Headers不超出以下几种字段：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type（只限于三个值：text/plain、multipart/form-data、application/x-www-form-urlencoded）</li>
<li>DPR</li>
<li>Downlink</li>
<li>Save-Data</li>
<li>Viewport-Width</li>
<li>Width</li>
</ul>
</li>
</ul>
<p>浏览器对这两种请求的处理是不同的。<br>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。然后根据服务器的响应来判断服务器上的资源是否允许该Origin访问。<br>如果是非简单请求，浏览器会首先使用<code>OPTIONS</code>方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。<br>服务器端可以设置Access-Control-Max-Age字段缓存预检请求的响应结果。在缓存有效期内，该资源的请求（URL和header字段都相同的情况下）不会再触发预检。注意，该缓存只针对这一个请求URL和相同的Header，无法针对整个域或者模糊匹配URL做缓存。</p>
<p>对于附带身份凭证（Cookie）的请求<br>要发送附带Cookie的请求到服务端，首先在客户端要将XMLHttpRequest的withCredentials属性标志设置为true。<br>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。<br>当服务器收到这个请求后，返回给浏览器的Response Headers中必须携带Access-Control-Allow-Credentials: true，否则即使浏览器收到response，也会拦截，不会把响应内容返回给请求的发送者。<br>另外，对于附带身份凭证的请求，服务器不得设置Access-Control-Allow-Origin 的值为”*”（这个值为”*”表明该资源可以被任意外域访问），而必须指定明确的、与请求网页一致的域名。<br>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
<h4 id="Restful接口规范介绍"><a href="#Restful接口规范介绍" class="headerlink" title="Restful接口规范介绍"></a>Restful接口规范介绍</h4><p>REST – Representational State Transfer 直接翻译：表现层状态转移。<br>Restful是一种接口设计风格 —— URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。<br>查询：GET<br>新增：POST<br>修改：PUT、PATCH<br>删除：DELETE</p>
<p>Restful风格的url设计的简单示例<br>rest协议是面向资源的，假如要管理一些用户，那么将用户看作是一种资源：</p>
<ul>
<li>GET /users/{userId}  获取userId对应的user信息</li>
<li>POST /users 创建一个新的user</li>
<li>PUT、PATCH /users/{userId} 更改userId对应的user信息</li>
<li>DELETE /users/{userId} 删除userId对应的user。</li>
</ul>
<p>Restful的六个约束</p>
<ol>
<li>Client-Server 客户端服务器分离<ul>
<li>优点，提高用户界面的便携性（操作简单）</li>
<li>通过简化服务器提高可伸缩性（高性能，低成本）</li>
<li>允许组件分别优化（可以让服务端和客户端分别进行改进和优化）</li>
</ul>
</li>
<li>Statusless 无状态，从客户端的每个请求要包含服务器所需要的所有信息<ul>
<li>提高可见性（可以单独考虑每个请求）</li>
<li>提高了可靠性（更容易从局部故障中修复）</li>
<li>提高可扩展性（降低了服务器资源使用）</li>
</ul>
</li>
<li>Cachable 缓存，服务器返回信息必须被标记是否可以缓存，如果缓存，客户端可能会重用之前的信息发送请求<ul>
<li>减少交互次数</li>
<li>减少交互的平均延迟</li>
</ul>
</li>
<li>Layered System 分层系统，封装服务，引入中间层。<ul>
<li>限制了系统的复杂性</li>
<li>提高可扩展性</li>
</ul>
</li>
<li>Uniform Interface 统一接口<ul>
<li>提高交互的可见性</li>
<li>鼓励单独改善组件</li>
</ul>
</li>
<li>Code-On-Demand 支持按需代码（可选）</li>
</ol>
<h4 id="GraphQL接口介绍"><a href="#GraphQL接口介绍" class="headerlink" title="GraphQL接口介绍"></a>GraphQL接口介绍</h4><p>GraphQL是一种API查询语言。<br>它可以将接口的返回值，从静态变为动态，即调用者来声明接口返回什么数据。很大程度上可以进一步解耦前后端的关联。<br>在GraphQL中，我们通过预先定义一张<code>Schema</code>和声明一些<code>Type</code>来达到上述效果，我们需要知道：</p>
<ul>
<li>对于数据模型的抽象是通过Type来描述的</li>
<li>对于接口获取数据的逻辑是通过Schema来描述的</li>
</ul>
<p>简单示例：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 文章</span><br>type ArticleType &#123;<br>  id: ID!<br>  text: String!<br>  isPublished: Boolean<br>  author: AuthorType<br>&#125;<br><br><span class="hljs-comment"># 作者</span><br>type AuthorType &#123;<br>  id: ID!<br>  name: String!<br>  age: Int<br>  articles: [ArticleType!]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>几个查询语句</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 只查询文章信息，不包含作者</span><br>query &#123;<br>  ArticleType &#123;<br>    <span class="hljs-built_in">id</span><br>    <span class="hljs-built_in">text</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment"># 查询文章信息，同时需要作者信息</span><br>query &#123;<br>  ArticleType &#123;<br>    <span class="hljs-built_in">id</span><br>    <span class="hljs-built_in">text</span><br>    author &#123;<br>      <span class="hljs-built_in">name</span><br>      age<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment"># 查询某个作者的文章</span><br>query(<br>  $authorId: ID!<br>) &#123;<br>  ArticleType(<br>    authorId: $authorId<br>  ) &#123;<br>    <span class="hljs-built_in">id</span><br>    <span class="hljs-built_in">text</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment"># 只查询作者信息</span><br>query &#123;<br>  AuthorType &#123;<br>    <span class="hljs-built_in">id</span><br>    <span class="hljs-built_in">name</span><br>    age<br>  &#125;<br>&#125;<br><br><span class="hljs-comment"># 查询作者信息，同时列出该作者的文章</span><br>query &#123;<br>  AuthorType &#123;<br>    <span class="hljs-built_in">id</span><br>    <span class="hljs-built_in">name</span><br>    age<br>    articles &#123;<br>      <span class="hljs-built_in">id</span><br>      <span class="hljs-built_in">text</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment"># 同时查询作者跟文章</span><br>query &#123;<br>  AuthorType &#123;<br>    <span class="hljs-built_in">id</span><br>    <span class="hljs-built_in">name</span><br>    age<br>  &#125;<br>  ArticleType &#123;<br>    <span class="hljs-built_in">id</span><br>    <span class="hljs-built_in">text</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述都是query语句，GraphQL一共有三种查询语句：</p>
<ul>
<li>query（查询）：当获取数据时，应当选取Query类型</li>
<li>mutation（更改）：当尝试修改数据时，应当使用mutation类型</li>
<li>subscription（订阅）：当数据更改时，希望进行消息推送，使用subscription类型</li>
</ul>
<p>个人总结GraphQL的几个缺点跟不足：</p>
<ul>
<li>优点<ul>
<li>减少请求冗余，传统的开发方式中需要多次请求的内容，使用GraphQL的方式可能只需要一次请求就可以完成</li>
<li>减少数据冗余，需要什么字段就查询什么字段</li>
<li>前后端之间的开发方式变得更加灵活，只要后端定义好了Schema，前端就可以根据自己的数据需求自定义查询语句</li>
</ul>
</li>
<li>不足<ul>
<li>资料比较少=.=！</li>
<li>相比一些成熟的开发模式，对某些方面的支持还不够好（缓存、错误处理等）</li>
</ul>
</li>
</ul>
<h4 id="TCP三次握手-amp-四次挥手"><a href="#TCP三次握手-amp-四次挥手" class="headerlink" title="TCP三次握手&amp;四次挥手"></a>TCP三次握手&amp;四次挥手</h4><p><strong>三次握手</strong></p>
<ol>
<li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li>
<li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1，如果有丢失的情况，则会重传。</li>
<li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li>
</ol>
<p><strong>四次挥手</strong><br>TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。这里简称为A方跟B方</p>
<ol>
<li>当A要关闭连接时，会发送FIN段告知B，我要关闭连接了。</li>
<li>B回复一个ACK，表示知道了，此时A的连接关闭。但B仍然可以继续传输数据。</li>
<li>等到B发送完了所有的数据后，会发送给A一个FIN段来关闭此方向上的连接。</li>
<li>A收到后发送ACK确认关闭连接。<blockquote>
<p>SYN —— 用于初始化一个连接的序列号<br>ISN —— 初始序列号<br>ACK —— 确认，使得确认号有效<br>RST —— 重置连接<br>FIN —— 该报文段的发送方已经结束向对方发送数据</p>
</blockquote>
</li>
</ol>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>对称加密：加密和解密用的是同一个密钥<br>非对称加密（RSA）：有一对密钥，一个是保密的，称为私钥；另一个是公开的，称为公钥。并且<strong>用私钥加密的数据，只有对应的公钥才能解密；用公钥加密的数据，只有对应的私钥才能解密。</strong></p>
<p>利用非对称加密的特性，当A给B发消息的时候，就可以先用B的公钥去加密，B收到消息，就用自己的私钥解密；反之，B给A发消息，就用A的公钥加密，A收到后用自己的私钥解密。</p>
<p>但是RSA算法的加密和解密速度比较慢，所以为了提高通信效率，通讯双方用非对称加密的方法传递对称加密的密钥，这样之后就可以用对称加密来通信。所以现在的问题就是如何安全地来传递公钥。</p>
<p><code>中间人劫持</code>：A给B发送的公钥被中间人C截取，然后C把自己的公钥发给B，冒充A。这样B收到的公钥就是C的，但是B会误以为这是A的公钥，B再用这个公钥对自己的公钥加密，发送给A（实际是C），C拿到信息后用自己的私钥解密，就得到了B的公钥，之后再如法炮制跟A进行通信，就如同一个中间人一样。</p>
<p>现在问题又回到了，如何声明一个公钥确实是发出者的而不是别人的。这时候，我们需要引入第三方，一个权威的证书颁发机构（CA）。</p>
<p>具体步骤：</p>
<ol>
<li>服务端将它的公钥跟一些基本信息（域名）等用Hash算法生成一个消息摘要（防止被篡改），申请CA机构认证。</li>
<li>CA机构用自己的私钥对消息摘要进行加密，形成数据签名；然后把服务端的消息摘要跟数据签名合并，形成一个全新的东西，叫做“数字证书”,签发给服务端。</li>
<li>客户端向服务端发出请求时，服务端返回数字证书。客户端读取证书中的相关的明文信息，采用相同的Hash算法计算得到信息摘要，然后，利用对应CA机构的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法。</li>
</ol>
<p>为了防止攻击者伪装成CA机构，这些CA机构本身也会有证书来证明自己的身份。CA的信用就像树级结构一样是分级的，高层的CA给下层的CA做信用背书，而操作系统&amp;浏览器中会内置一些顶层的CA证书，相当于自动信任了他们。</p>
<h4 id="课外阅读"><a href="#课外阅读" class="headerlink" title="课外阅读"></a>课外阅读</h4><ul>
<li><a href="https://wsgi.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">WSGI 官方文档</a></li>
<li><a href="http://uwsgi-docs.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">uWSGI 官方文档</a></li>
<li><a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">PEP3333</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">HTTP访问控制（CORS） - MDN</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>web</tag>
        <tag>WSGI</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中getattr、__getattr__、__getattribute__的区别</title>
    <url>/2020/03/12/Python%E4%B8%ADgetattr%E3%80%81__getattr__%E3%80%81__getattribute__%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="getattr"><a href="#getattr" class="headerlink" title="getattr"></a>getattr</h4><p>getattr (object, name[, default])是Python的内置函数，它的作用是获取对象的属性。</p>
<ul>
<li>object 对象</li>
<li>name 属性名</li>
<li>default 当属性不存在时，返回的默认值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs $python3">class Foo:<br>    def __init__(self, x):<br>        self.x &#x3D; x<br><br>f &#x3D; Foo(x&#x3D;10)<br>a &#x3D; getattr(f, &quot;x&quot;)<br>print(a)  # &gt;&gt;&gt; 10<br>b &#x3D; getattr(f, &quot;y&quot;, &quot;NaN&quot;)<br>print(b)  # &gt;&gt;&gt; NaN<br></code></pre></td></tr></table></figure>
<p><em><code>实际调用的就是__getattribute__方法</code></em></p>
<h4 id="getattr-1"><a href="#getattr-1" class="headerlink" title="__getattr__"></a>__getattr__</h4><p>重载__getattr__方法对类及其实例<strong>未定义</strong>的属性有效。也就属性是说，如果访问的属性存在，就不会调用__getattr__方法。包括类属性和实例属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span><br>        self.x = x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, item)</span>:</span><br>        print(<span class="hljs-string">f"调用__getattr__"</span>)<br>        print(<span class="hljs-string">f"属性<span class="hljs-subst">&#123;item&#125;</span>不存在"</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"__getattr__"</span><br><br>f = Foo(x=<span class="hljs-number">10</span>)<br>print(f.x)<br>print(<span class="hljs-string">"*"</span> * <span class="hljs-number">20</span>)<br>print(f.y)<br></code></pre></td></tr></table></figure>
<p>返回结果</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">10<br><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><br>调用<span class="hljs-strong">__getattr__</span><br>属性y不存在<br><span class="hljs-strong">__getattr__</span><br></code></pre></td></tr></table></figure>

<h4 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a>__getattribute__</h4><p>当访问某个对象的属性时，会无条件的调用__getattribute__方法<br><strong>所以为了避免在方法中出现无限递归的情况，应该总是使用基类的方法来获取属性。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span><br>        self.x = x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattribute__</span><span class="hljs-params">(self, item)</span>:</span><br>        print(<span class="hljs-string">f"调用__getattribute__, 属性值:<span class="hljs-subst">&#123;item&#125;</span>"</span>)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> super().__getattribute__(item)<br>        <span class="hljs-keyword">except</span>:<br>            print(<span class="hljs-string">f"<span class="hljs-subst">&#123;self&#125;</span>不存在<span class="hljs-subst">&#123;item&#125;</span>属性"</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">"__getattribute__"</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f"类Foo(x)"</span><br><br>f = Foo(x=<span class="hljs-number">10</span>)<br>print(f.x)<br>print(<span class="hljs-string">"*"</span> * <span class="hljs-number">20</span>)<br>print(f.y)<br></code></pre></td></tr></table></figure>
<p>返回结果</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">调用<span class="hljs-strong">__getattribute__</span>, 属性值:x<br>10<br><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><br>调用<span class="hljs-strong">__getattribute__</span>, 属性值:y<br>类Foo(x)不存在y属性<br><span class="hljs-strong">__getattribute__</span><br></code></pre></td></tr></table></figure>

<p>另外，当同时定义__getattribute__和__getattr__时，__getattr__方法不会再被调用，除非显示调用__getattr__方法或引发AttributeError异常。</p>
<p>同时存在__getattribute__和__getattr__时，__getattr__方法不会再被调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span><br>        self.x = x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"__getattr__"</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattribute__</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"__getattribute__"</span><br><br>f = Foo(x=<span class="hljs-number">10</span>)<br>print(f.x)<br>print(<span class="hljs-string">"*"</span> * <span class="hljs-number">20</span>)<br>print(f.y)<br></code></pre></td></tr></table></figure>
<p>返回结果</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-strong">__getattribute__</span><br><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><br><span class="hljs-strong">__getattribute__</span><br></code></pre></td></tr></table></figure>

<p>引发AttributeError异常时，__getattr__方法会再被调用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span><br>        self.x = x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"__getattr__"</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattribute__</span><span class="hljs-params">(self, item)</span>:</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> super().__getattribute__(item)<br>        <span class="hljs-keyword">except</span> AttributeError:<br>            <span class="hljs-keyword">raise</span> AttributeError<br><br>f = Foo(x=<span class="hljs-number">10</span>)<br>print(f.x)<br>print(<span class="hljs-string">"*"</span> * <span class="hljs-number">20</span>)<br>print(f.y)<br></code></pre></td></tr></table></figure>
<p>返回结果</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">10<br><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><span class="hljs-strong">*****</span><br><span class="hljs-strong">__getattr__</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python进阶</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>用Python实现一些数据结构</title>
    <url>/2018/02/21/%E7%94%A8Python%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">self</span>.items = []<br><br>    @property<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 返回栈的项目数</span><br>        <span class="hljs-keyword">return</span> len(<span class="hljs-keyword">self</span>.items)<br><br>    @property<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 显示栈是否为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.size == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 新项添加到堆栈的顶部, 需要参数item并且没有返回值</span><br>        <span class="hljs-keyword">self</span>.items.append(item)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 从栈顶删除项目, 它不需要参数, 返回item, 栈被修改</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">items:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.items.pop()<br>        raise IndexError(<span class="hljs-string">"pop from empty stack"</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peek</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 返回栈顶的项, 不删除, 堆栈不被修改</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">items:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.items[<span class="hljs-keyword">self</span>.size - <span class="hljs-number">1</span>]<br>        raise IndexError(<span class="hljs-string">"peek from empty stack"</span>)<br></code></pre></td></tr></table></figure>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="单向队列"><a href="#单向队列" class="headerlink" title="单向队列"></a>单向队列</h5><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">self</span>.items = []<br><br>    @property<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 返回队列的项目数</span><br>        <span class="hljs-keyword">return</span> len(<span class="hljs-keyword">self</span>.items)<br><br>    @property<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 显示队列是否为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.size == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 将数据项添加到队尾, 无返回值</span><br>        <span class="hljs-keyword">self</span>.items.insert(<span class="hljs-number">0</span>, item)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 队首移除数据项, 返回值为队首数据项</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">items:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.items.pop()<br>        raise IndexError(<span class="hljs-string">"dequeue from empty queue"</span>)<br></code></pre></td></tr></table></figure>

<h5 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h5><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deque</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-keyword">self</span>.items = []<br><br>    @property<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 返回队列的项目数</span><br>        <span class="hljs-keyword">return</span> len(<span class="hljs-keyword">self</span>.items)<br><br>    @property<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 显示队列是否为空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.size == <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_front</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 在队首插入一个元素，参数为待插入元素，无返回值</span><br>        <span class="hljs-keyword">self</span>.items.insert(<span class="hljs-number">0</span>, item)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_rear</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, item)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 在队尾插入一个元素，参数为待插入元素，无返回值</span><br>        <span class="hljs-keyword">self</span>.items.append(item)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_front</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 在队首移除一个元素，无参数，返回值为该元素。双端队列会被改变</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">items:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.items.pop(<span class="hljs-number">0</span>)<br>        raise IndexError(<span class="hljs-string">"remove from empty deque"</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_rear</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span><span class="hljs-symbol">:</span><br>        <span class="hljs-comment"># 在队尾移除一个元素，无参数，返回值为该元素。双端队列会被改变</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">items:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.items.pop()<br>        raise IndexError(<span class="hljs-string">"remove from empty deque"</span>)<br></code></pre></td></tr></table></figure>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
